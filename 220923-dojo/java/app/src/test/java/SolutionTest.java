// 문제좀 해석해보기. 뭐라는거야...

// %% 기본 룰 %%
// 1. 어피치가 n발 다 쏘고 라이언이 화살 n발을 쏨. 즉 같은 갯수의 화살을 쏨.
//   - 과녁판은 10-9-8-...-0점까지 존재함
// 2. 점수계산법
//   - 한사람이 한 점수를 여러번 맞추더라도 그 점수만큼만 가져감(이건 둘다 공통). 0은 해당사항 없음
//   - 예. 어피치가 3점에 5발, 라이언이 3점에 6발을 맞췄다고 치면 라이언이 한발 더 맞췄으니까 점수를 가져가는데
//   - 3 * 18점이 아니라 3점만 가져감
//   - 근데 둘이 맞춘 횟수가 같으면 어피치 어드밴티지. 어피치한테 점수 몰아주기(실화냐?)
// 3. 우승자 선정법
//   - 최종점수가 높은 선수가 우승자. 하지만 동점일 경우 이 경우도 어피치가 우승자. . .

// 어피치는 n발 다 쏨 => 이 말인 즉슨 라이언 손에 쥐인 화살도 n개라는 말.
// 하고자 하는 것? 라이언이 어피치를 '가장 큰 점수차'로 이기는 것
// 구해야 할 것? n발의 화살을 어떤 과녁 점수에 맞춰야 하는지를 리턴

// 자연수 n = 화살의 갯수
// 어피치가 맞힌 과녁점수의 개수를 10점 - 0점 순으로 담은 정수배열 info
// 라이언이 가장 큰 점수차로 우승하기 위해 n발 화살을 어떤 과녁 점수에 맞춰야 하는지를 정수배열에 내림차숨으로 담아 return해볼 것
// 만에 하나 라이언이 우승 불가(또는 무조건 비기는 겜) 경우 [-1] return 하기
// 또 가장 큰 점수차이로 우승할 수 있는 방법이 여러개면 가장 낮은 점수를 더 많이 맞힌 경우를 리턴할 것

// 그럼 지금 여기에서 가장 먼저 할 수 있는 것은 무엇이냐?
// 어피치가 이미 다 쐈기 때문에. 어피치의 총점을 먼저 구하는 것이 우선 아닐까? 그래야 라이언과 뭘 비교를 하든 할테니.
// 근데 총점을 구하는게 우선일까, 서로 맞힌 화살개수를 비교해나가면서 하는게 우선일까... 흠.
// 총점이 먼저인 것 같다. 어피치 총점을 먼저 구하고 나서 그 총점보다 점수를 더 많이 낼 수 있는 경우의 수를 찾아야 할듯.
// 아니근디. 총점이랄게 결국엔 라이언이랑 연결되는건ㄷ ㅔ . . . .하. 총점에서 라이언이 이기는 경우의 점수를 까야하나.
// 어피치가 다 씹어먹은 것을 전제로 해서 라이언이 이길 경우의 점수를 까고, 반대로 라이언한테는 카운트를 더하는 것은 어떤가?

// 아... 약간 표 보다보니까 알것같기도 하고.
// 어피치가 맞힌 화살개수 배열을 보면서 가장 높은점수(10점)를 맞춘 개수보다 하나씩 크게 해서 배열을 만들고 이를 반복하면 되는듯.
// 아예 예를 딱 들어야겠다.
// 예. 어피치가 10점을 10개맞췄다고 치자.(n도 10) 그럼 라이언이 들고있는 화살이 어피치가 최고점수를 맞춘 10개 화살보다 적어도 1개는 더 많아야 함
// 근데 없기 때문에 얘는 그냥 [-1] 리턴해야 함
// 가장 고점을 맞춘 개수보다 1개씩만 더 맞춰가면서 내려오면 되는듯 그래서 카온트를 다 한다음에 그중에 제일 점수가 높은 걾
// temp 변수같은 임시변수에 저장해놓고 매 회차마다 나오는 결과값과 temp를 비교하는 방식이 제일 합리적이어보임.
// 주어진 예시중에 n == 1, info[0]이 1인 info. 이거의 result가 -1이 나오도록 해보자.
// 얘를 좀더 일반화 시켜보면... info 어레이 원소중에 n이 포함되어 있으면(contains) 조금 간단해지지 않나?
// 즉 n이 포함된 위치보다 더 높은 점수(n이 포함된 인덱스보다 무조건 낮아야겠지)를 라이언이 1개라도 맞추면 라이언이 이기는거고. (비기거나 지면 안되니까)
// 라이언이 최대점수차로 이기려면 n을 10점부터 그냥 1개씩 뿌려주고(중복은 쳐주지 않으니까)
// 어피치가 맞춘 그 인덱스만 피해서 뿌리면 되지 => 그건 점수로 안쳐주니까 실점을 최대한 막는 것
// 그러면 어레이는 완성될 듯. 그 부분에 대해서만 해보자.
// 위 가설은 틀렸다. 샘플 2에서 바로 드러나버렸음. 결국 어레이에 원소가 있는지를 확인하면서&&점수까지 확인해야 하는건가...
// 그럼 메소드가 2개로 쪼개질 수 있을 것 같다. 1. 어피치의 점수를 구하는 메소드, 어피치 점수 & info, n 3개의 인자를 들고 들어가는 메소드
// 어피치 점수 구하는 것부터 만들어보자. ㅎ ㅏ.. 근데 총점이란게 결국 내가 다 이겼다는걸 전제로 하고 구하는건데. . . . . 맞는건가.

import org.junit.jupiter.api.*;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;

class SolutionTest {
//  @Test
  void sample1() {
    Solution solution = new Solution();

    int n = 1;
    int[] info = new int[]{1,0,0,0,0,0,0,0,0,0,0};

    solution.process(n, info);
    assertArrayEquals(solution.solution(n, info), new int[]{-1});
  }

//  @Test
  void sample2() {
    Solution solution = new Solution();

    int n = 2;
    int[] info = new int[]{0,1,1,0,0,0,0,0,0,0,0};

    solution.process(n, info);
    assertArrayEquals(solution.solution(n, info), new int[]{-1});
  }

  @Test
  void getApeachScore1() {
    Solution solution = new Solution();
    int[] info = new int[]{1,0,0,0,0,0,0,0,0,0,0};

    assertEquals(solution.apeachTotalScore(info), 10);

  }

//  @Test
  void getApeachScore2() {
    Solution solution = new Solution();
    int[] info = new int[]{0,1,1,0,0,0,0,0,0,0,0};

    assertEquals(solution.apeachTotalScore(info), 17);
  }
}
