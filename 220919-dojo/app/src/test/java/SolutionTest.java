import org.junit.jupiter.api.*;

import static org.junit.jupiter.api.Assertions.assertEquals;

// 가로, 세로 길이가 n인 정사각형으로 된 체스판이 있음
// 체스판 위의 n개의 퀸이 서로 공격할 수 없도록 배치하고자 함
// 정사각형 한편의 길이 n이 매개변수
// n개의 퀸이 조건에 만족하도록 배치할 수 있는 방법의 수를 리턴

// 제한사항 => 퀸은 가로, 세로, 대각선으로 이동 가능
// n은 12 이하의 자연수

// 경우의 수를 생각해보자.
// 1. 첫번째 줄에 자리잡을 수 있는 경우의 수 = n개. 왜냐면 아무데나 갈 수 있으니까?
// 2. 두번째 줄에 자리잡을 수 있는 경우의 수? => 우선 윗줄의 컬럼은 아니어야 함. 그럼 컬럼에 대한 갯수 1개 빠지고
//                                   => 그리고 위에 q의 대각선 자리에도 없어야 함. 그럼 대각선 자리 2개 빠지고
//                                   => 결론: n - 3의 경우의 수?
//                                   => 근데 예외가 있음. 만약 위에있는 q이 양쪽 끝에 자리할 경우 자리 1개만 빼면됨
// 3. 세번째 줄에 자리잡을 수 있는 경우의 수? => 첫번째 줄 컬럼 빼고, 두번째 줄 컬럼도 빼고. 2개 까고 시작
//                                   => 대각선은 바로 위에 애만 신경쓰면 됨. 바로 위 q의 대각선 자리만 빼자. 2개.
//                                   => 근데 예외가 있음. 만약 위에있는 q이 양쪽 끝에 자리할 경우 자리 1개만 빼면됨

// 아예 예시로 생각해보자.
// 1. n이 1이면. 가로 세로 길이 1. 체스판 위에 1개의 퀸 => 경우의 수 1
// 2. n이 2이면 가로 세로 길이가 2. (2X2 배열). 2개의 퀸. 경우의 수 0
// 3. n이 3이면 가로 세로 길이가 3. (3X3 배열). 3개의 퀸. 경우의 수 2
// 4. n이 4이면 가로 세로 길이가 4. (4x4 배열). 4개의 퀸. 경우의 수 2
// ...

// 정리해보면...
// n을 입력받았을 때 n x n의 2차원 배열을 만들수 있을 것 같다.
// row를 천천히 돌리면서. column도 천천히 돌리고...
// 배열을 만들어볼까.

// 좀 더 간단한 방법 없나...?
// n이 4라고 치면. 첫줄을 1을 선택했을 때.
// 그럼 두번째 줄은 0, 2빼고 3, 4 가능. 3이라고 칠 때
// 그럼 세번째 줄은 바로 위에서 선택한 3을 포함해서 그의 앞뒤인 2, 4만 빼고 1만 가능
// 그럼 마지막 줄은 바로 위에서 선택한 1, 그리고 그 바로 옆인 2 빼고 3, 4 가능


class SolutionTest {
  @Test
  void oneByOneMatrix() {
    Solution solution = new Solution();

    int n = 1;
    int[][] matrix = new int[n][n];

    assertEquals(solution.process(matrix, n), 1);
  }

  @Test
  void twoByTwoMatrix() {
    Solution solution = new Solution();

    int n = 2;
    int[][] matrix = new int[n][n];

    assertEquals(solution.process(matrix, n), 0);
  }
}
